\documentclass[a4paper,11pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{graphicx}
\usepackage{array}
\usepackage{enumitem}
\usepackage{listings}
\usepackage[utf8]{inputenc}
\usepackage[francais]{babel}
\usepackage{parskip}
\setlength{\parskip}{10pt plus 0pt minus 0pt}
\usepackage[left=2cm, right=3cm]{geometry}

\usepackage{upquote}


\begin{document}


\chapter{Introduction}


\chapter{Le contexte du travail}
\section{Le cahier des charges ?}
\section{L'architecture de la plateforme cible}
\section{Le framework Angularjs ?}

AngularJS\footnote{url de angular} est un framework écrit en javascript par Google libre et
open-source qui permet d'améliorer  la syntaxe de javascript ainsi que la productivité du
développeur. Il étend le HTML pour le rendre dynamique, et permet de développer ses propres
balises et attributs HTML. C’est un framework qui se veut extensible et qui pousse vers un 
développement structuré, en couches, le but n’étant pas d’ajouter de simples animations au
DOM, mais bien d’apporter un aspect applicatif au front-end. AngularJS est construit autour
de concepts 
\subsection{Pourquoi angularJS}

\subsection{Concept}
Angular est construit autour de concepts et de bonnes pratiques
incontournables dans le monde du développement web.

\begin{itemize}
 \item 
\end{itemize}

   
  

\section{Les ressources REST}
Un API REST est un système D'URIs, les ressources déterminent la structure des URIs par 
conséquent  la manière dont une application trouve les données qu'elle manipule.
REpresentational State Transfer (REST) est un style d’architecture pour les systèmes
distribués bâti sur des APIs permettants de centraliser des services partagés. Il est 
donc évident que plusieurs applications technologiquement hétérogènes utilisent ces services
via un réseau. Par exemple, on peut créer un compte Instagram\footnote{C'est quoi instagram}
utilise avecles données de son compte facebook via un API de face





\section{Le contrôle d'accès en utilisant des rôles (RBAC)}

\chapter{La Conception de notre générateur de module}
\section{Le concept général}
\subsection{Définition d'un module}

%Le concept de module dans une architecture client-serveur représente
%un ensemble d'éléments côté client interagissant avec d'autres
%éléments côté serveur.
Un module est une application métier\footnote{A expliquer} basée sur
l'architecture client-serveur. Nous nous référons au terme module pour
indiquer le caractère modulaire que peut prendre une application. Par
exemple,la gestion des resources humaines est un assemblage de
plusieurs sous-applications telles que la gestion des employés, la
gestion des carrières, la gestion de la paie et la gestion des
embaûches \footnote{donner la liste complète si possible}. 

L'architecture client-serveur, implique qu'un module est composé
d'une application {\em client} et d'une application {\em serveur}.
L'application client est une interface graphique\footnote{spécifier
  pourquoi c'est une interface graphique } permettant à
aux utilisateur d'interagir avec un système d'information.
%faut il parler des single page ?
L'application serveur est celle qui gère les données métiers dans un
système d'information.
La gestion des données est faite essentiellement via une base de
données et les processus métiers. 

\subsection{Le portail applicatif des modules}
%penser à definir la   %notion de SPA, s'assurer que module est
%défini%
C'est l'interface principale\footnote{parler du PAE} permettant 
de présenter les différentes fonctionnalités des modules. Comme
le montre la figure \ref{}, elle est divisée en six parties à savoir :

\begin{itemize}
\item La barre d'entête (cf. le chiffre 1 sur la figure \ref{}). Cette
  partie indique le nom du module courant, la liste des tâches à
  réaliser et la liste des modules.
\item  Le bloc de menus  (cf. le chiffre 2 sur la figure \ref{}). Il
  présente les différents éléments du menu d'un module.
\item Le bloc des modules liées  (cf. le chiffre 3 sur la figure
  \ref{}). Présente la liste des modules en lien avec le module courant.
\item  L'espace de travail  (cf. le chiffre 4 sur la figure
  \ref{}).
  
\item La barre d'actions  (cf. le chiffre 5 sur la figure \ref{}). 
 
\end{itemize}

L'nterface est basée sur la notion d'applications
monopages\footnote{Aussi nommée Single Page Application (SPA) }.
De ce fait, les parties une, deux, trois et cinq sont statiques alors
que la partie 4 est dynamique. Les éléments des parties statiques
changent avec l'installation d'un nouveau module.
   
\paragraph{Actions versus menu.}
Les éléments du menu permettent de naviguer à travers les
différentes vues d'un module alors que les actions permettent de
faire des opérations sur les éléments de la vue courante. D'un point
de vue technique, la différence se trouve au niveau des composants avec
lesquels ils sont implmentés : les menus sont implémentés   sous forme
de liens et les actions boutons. 

\paragraph{Liste des modules versus modules liés}
La liste des modules de la barre d'entête représente l'ensemble des
modules installés sur le système tandisque la liste des modules liés
représente les dépendances entre différents modules. Les modules de
gestion de stocks et d'achats sont liés ou dépendent du module de la
gestion des articles. Dans ce cas de figure, le module gestion des
articles aura dans sa liste de modules liés les modules stocks et
achats. L'intérêt principal des modules liés est d'éviter à
l'utilisateur, d'aller chercher un module parmi une liste de module
qui peut vite être conséquent.

\paragraph{L'installation d'un module.}
Elle consiste, pour un module donné, à  fournir les éléments de
parties statiques. ces dernières sont ensuite positionnées dans leur
bloc respectif.

\subsection{Le principe générale \label{par:product}}
%A completer
%parler de productivité générale
%donner tout ce qui contribut à l'amélioration de cette dernière

L'idée du générateur est d'utiliser un environnement graphique
permettant de spécifier les différents éléments nécessaires à
l'implémentation des applications client et serveur, en vue d'augmenter
la productivité générale \footnote{listing des productivités} d'un développeur. En effet, une fois les
éléments spécifiés, nous passons à la génération automatique des codes
des applications client serveur. Ceci permettra aux développeurs de se
focaliser sur la conception de leurs modules.

Nous regroupons les éléments du module en deux catégories : ceux {\em
  côté client } et ceux {\em côté serveur}.
Les éléments côté client sont ceux qui sont nécessaires pour la mise
en place de l'interface principale. Ils permettent de définir les
différentes pages ou vues html ainsi que les services qui permettent
de recupérer les données du serveur.
Les éléments côté serveur permettent de définir les bases de données,
les processus métiers et ressources permettant d'interagir avec le
client.

\paragraph{Productivité. } Nous la définissons comme le temps nécesssaire à un
dévelopeur pour implémenter, tester et pour déployer une
application. Dans ce travail nous nous intéressons aux éléments qui
font perdre du temps durant l'implémentation d'une application ; nous
les avons regroupé comme suit :
\begin{itemize}
\item {\em les erreurs de syntaxe}. Beaucoup d'erreurs dans
  l'implémentation d'une application sont dues à des erreurs de syntaxe
  ou des erreurs de frappe dans le nom des fonctions ou des variables.
\item {\em la recherche à l'aveugle}. Rechercher des informations
  telles que la valeur d'une variable ou la définition d'une fonction
  peut vite devenir fastidieux lorsqu'on travaille sur de grosses
  applications.
\item {\em code ennuyeux}. Les développeurs perdent beaucoup du temps
  à chercher comment implémenter certain de leur concept dans des
  langages qu'ils n'apprécient pas ou qu'ils ne maîtrisent. Ils
  perdent aussi du temps à écrire plusieurs fois le même code.
\item {\em distraction?}
\end{itemize}

Nos solutions pour améliorer la productivé des développeur tournent
autour de la réutilisation, l'isolation , la génération et la
modularité de code. Dans le reste du document nous allons ... bla bla
bla.


\section{La présentation des éléments graphiques côté client}
%parler du MVC (séparation des vues de la donnée)%
\subsection{Overview}

\subsubsection{Présentation de la vue générale}
La vue générale se concentre sur les éléments côté client d'un
module. Elle est l'étape principale dans le processus de réalisation
d'un module. Aussi simple qu'elle parait, elle rassemble tous les
outils nécessaires pour concevoir chacun des éléments de la partie
cliente d'un module. Elle se résume à l'interface de la figure
suivante. Sous les onglets {\tt components} et {\tt treeview}, nous
disposons respectivement de la palette de composants html et de leur
organisation sur la vue en forme d'arborescence. sous les onglets {\tt
variables} et {\tt functions}, on définit les variables et les
fonctions qui sont utilisées pour écrire le contrôleur de la vue. Sous
les onglets {\tt actions} et {\tt configs} on définit respectivement
les actions du module et les paramètres de configuration de la vue. 


\subsubsection{ Les composants} % faut il lister les éléments
Ils constituent un outil graphique permettant de manipuler les
éléments qui entrent dans l'élaboration d'une interface web. Les
manipulations sont basées sur un certains nombres de propriétés que 
nous leur avons associé afin de controller leur mise en forme, leurs
attributs html ainsi que les données qu'ils manipulent.

Nous avons resencé les composants les plus couremment utilisés dans les
applications web et nous les avons regroupé en trois grandes
catégories :

\begin{itemize}
\item {\em Les composants simples};
ce sont des éléments HTML dont la définition ne nécéssite pas
l'imbrication d'un autre composant.
exemple:
%mettre un exemple délément simple
\item  {\em Les composants conteneurs} 
Ce sont des éléments qui peuvent contenir des composants de
n'importe quelle catégorie, par exemple l'élément html {\tt form}
permet de regrouper les composants simples tels que les {\tt input} et
des {\tt button} pour la réalisation d'un formulaire.
\item Les composants widgets
Ce sont des éléments non standards que nous avons entièrement écris, en
proposant leur design et leur conception.
\end{itemize}



\subsubsection{ L'arbre des composants} 
%mettre une note de bas de page pour dire les difficultés que
%rencontrent les dévelopeurs
Le concept de l'arbre des composants est d'augmenter la productivité
des dévéloppeurs en limitant le perte de temps due aux changements
récurents dans le développement des interfaces \footnote{explication détaillée}.


L'arbre des composants est un outil permettant de représenter les
composants d'une interface. Ses composants sont organisés sous forme
d'arbre afin de mieux schématiser la hiérarchie induite par les
composants conteneurs. La figure \ref{} représente l'arbre des
composants de l'interface de la figure \ref{}.

Notre concept se décline via l'interface de la figure \ref{} dans
laquelle on constate qu'un certains nombres d'actions sont associées à
chaque composant. En effet pour permettre la réutilisation de codes
nous proposons les cinq actions suivantes:

\begin{itemize}
\item Monter - descendre : elles permettent les déplacements de
  composants vers le haut ou vers le bas, dans le même conteneur. Ceci
  permet de réorganiser les composants d'un même conteneur.

\item couper : elle permet les déplacements de composants d'un
  conteneur à un autre. Ceci permet la réorganisation globale des
  composants.
\item copier : permet de cloner
 un composant, soit dans un même
  conteneur ou non. Ceci permet de générer facilement une interface avec
  des composants semblables.
\item Supprimer : elle permet d'enlever un composant de l'arborescence.
\end{itemize}

% Introduire les propriétés des composants, parler de maniere gle du
% design, de la vue et du controleur%
%montrer àpartir d'un exemple, decrire les différentes propriétés des
%composants%
%faire une reférence vers la description des autes composants se
%trouvant en annexe%
	

\subsubsection{ Les fonctions}
Le concept ici est d'améliorer la productivité du dévloppeur en :
\begin{itemize}
\item évitant les {\em erreurs d'écriture} dans les noms des
fonctions dans les vues et dans les contrôleurs.
\item proposant une {\em vue d'ensemble} du travail à réaliser (isolation ?).
\end{itemize}

Le concept se décline via l'inteface de la figure \ref{}

\paragraph{Erreur d'écriture}
Le lien \og generate functions \fg, génère les noms des fonctions, à
partir de l'arbre des composants. Les composants tels que button,
... et ... font appel à des fonctions qu'ils définissent dans leurs
propriétés. à partir des propriétés des composants cités plus haut,
nous extrayons le nom des variables à déclarer.

\paragraph{Vue d'ensemble}
Nous pouvons dinstinguer parmi les variables à définir, celles qui
sont dejà définies ou non. La définition d'une variable se fait en
l'isolant des autres variables. Ceci permet au
développeur de se focaliser sur le reste des variables et surtout de
ne pas perdre de temps à chercher une information dans les codes qui
peuvent rapideent devenir illisibles.

\subsubsection{Les variables}
Le concept ici est d'améliorer la productivité du dévloppeur en :
\begin{itemize}
\item évitant les {\em erreurs d'écriture} dans les noms des
fonctions dans les vues et dans les contrôleurs.
\item proposant une {\em vue d'ensemble} du travail à réaliser.
\item simplifiant la déclaration des variables.

\end{itemize}

Le concept se décline via l'inteface de la figure \ref{}

\paragraph{Erreur d'écriture.}
Le lien \og generate vars \fg, génère les noms des variables, à partir
de l'arbre des composants. Les composants manipulent des variables. à
partir des propriétés, nous extrayons
le nom des variables à implémenter.

\paragraph{Vue d'ensemble.}
Nous pouvons dinstinguer parmi les fonctions à implémenter, celles qui
sont dejà définies ou non. La définition d'une fonction se fait en
l'isolant\footnote{collapsible} des autres fonctions. Ceci permet au
développeur de se focaliser sur le reste des fonctions et surtout de
ne pas perdre de temps à chercher une information dans les codes qui
peuvent rapideent devenir illisibles.

\paragraph{Déclaration.}
Les variables peuvent être de type {\em resolve}, {\em async} et {\em
  cache}.  les variables de type {\em resolve} sont celles dont les
valeurs sont présentes avant le chargement de la page qui les utilise.
les variables de type {\em async} sont celles dont les valeurs
proviennent d'un serveur de manière asynchrone; dans ce cas, le
service permettant d'obtenir la donnée doit être préciser.  Les
variables de type {\em cache} sont celles dont les valeurs sont mises
ou proviennent d'un cache lorsque l'attribut cache a pour valeur {\tt
  to} ou  {\tt from}.

%service, %expliquer le
%type locale
%%

\subsubsection{ Les actions}

Ils constituent un outil graphique permettant de spécifier les actions
associées à une vue donnée.

représentent une partie des fonctionnalités
du module faisables à partir de la vue encours d'édition.  Pour
ajouter une fonction, il faut :
\begin{itemize}
\item Préciser le nom de l'action;
\item  Préciser le rôle de l'utilisateur qui peut y avoir accès;
\item Préciser l'icône  de l'action, c'est sur cette dernière qu'il faut cliquer pour exécuter l'action;
\item Préciser les dépendances;
awesome file input\item Enfin écrire le corps de la fonction de l'action
\end{itemize}

 

\subsubsection{ La configuration} 
%lobjectif depuis le debut etait deja de cacher des parties de
%l'implémentation.
Le  concept ici est d'améliorer la productivité du développeur en
simplifiant la mise en place des menus, des droits et de la navigation.
Ce concept se décline via l'interface de la figure suivante \ref{}.

\paragraph{Navigation.}
Elle consiste à construire l'état/route auquel(le) la vue est associée
tout en précisant le nom de l'état, l'url associé et le chemin static
ou dynamic du template. Ainsi, en parcourant la liste des vues, on peu
les connaître les différents états du module.
 
\paragraph{Menus.}
La case à cocher \og module menu \fg permet de spécifier si une vue
a une entrée ou non dans la liste des menus d'un module.  De ce fait,
il est possible en parcourant la liste des vues de la figure \ref{},
d'obtenir les éléments du menu. On pourra non seulement identifier
les icônes associées aux menus mais aussi changer l'ordre d'apparition
des éléments dans le menu par un simple déplacement dans la liste des vues.
 
\paragraph{Droits d'accès}

\section{La présentation des éléments graphiques côté serveur}


L'idée est de proposer un concept permettant le développement des APi
restful de manière simple et conviviale. le développement des Api passe non
seulement par la définition de chaque ressource mais aussi par la définition
des fonctions ou méthodes associées aux différentes ressources.

Dans cette section nous présentons la définition des ressources ainsi
que les concepts que nous avons défini autours des ressources. Dans un
premier temps, nous avons introduit les concepts d'{\em héritage} et
de {\em déclencheur} dans la définition des ressources afin de
faciliter la structuration des grosses applications et de renforces de
manière générale la modularité de code. Dans un second temps nous
avons implémenté une ressource pour réaliser le chainage de ressources
et une autre pour l'indexation de données ; ceci afin de limiter la
perte de temps due à la procrastination et les code ennuyeux
(cf. paragraphe \ref{par:product})

\subsubsection{La définition de ressources}

Elle se fait via l'interface de la figure \ref{}. L'interface est
composée de trois parties. la partie $1$ permet d'avoir une liste
hiérachisée des ressources déjà déclarées tandis que les parties $2$
et $3$ permettent, en isolant les ressources, de voir leur définition et
de les compléter éventuellement.

%%plus de détail si possible

\subsubsection{L'héritage de ressources}

L'idée est, d'une part, d'exploiter la définition et l'implémentation
des ressources d'un module dans un autre module. D'autre part il nous
permet de simplifier les droits d'accès aux ressources générique (à
expliquer car pas trop clair). 

Soient le module {\tt personne} et le module {\tt client} qui hérite
de {\tt personne}. Les tables \ref{} et \ref{} présentent
respectivement les ressources de {\tt personne} et ceux heritées de
{\tt client}. Un client étant une personne, nous pouvons alors utiliser 
l'implémentation des resources du module {\tt personne} pour avoir la 
liste des clients. La particularité de l'héritage est que l'uri des ressources
de {\tt client} n'ont pas la même base que ceux des ressources {\tt personne} ;
ceci permet  au module {\tt client} de spécifier ses propres droits d'accès 
sur les ressources provenant de {\tt personne}. Ce type de gestion des droits
nous permet d'éviter l'attribution de droits trop complexe et pas toujours efficace.
En effet, si les modules {\tt travailleur}  et {\tt client} héritent de {\tt personne},
il sera impossibe pour un utilisateur ayant uniquement des droits sur {\tt travailleur}
d'accéder aux ressources {\tt client}. Si nous mettons des droits sur les ressources
de {\tt personne}, tout utilisateur ayant les droits sur {\tt travailleur} devra aussi
avoir des droits sur {\tt personne}, ce qui lui permettra par un effet de bord d'accéder
aux ressources de clients sans y avoir les droits.


\subsubsection{Déclencheur}

C'est un mécanisme permettant de faire exécuter des tâches en arrière plan 
après une exécution réussie d'une ressource, sur le serveur. Par exemple,
après une authentification réussie, il est possible de déclencher des tâches sur 
l'utilisateur en utilisant un déclencheur.


\subsubsection{Ressources chaînées}
\subsubsection{La ressource d'indexation}


\subsubsection{Les opérations}
Les opérations sont étroitement liées aux ressources

\subsubsection{Les données Externes}%base de données + process%


\chapter{Implémentation}

\section{Introduction}

\section{La structure interne d'un module}

Nous utilisons un document json pour le stockage des différents éléments d'un module.
Le document json est organisé autour des 5 attributs  présentés dans la table \ref{si:mod}.
L'attribut {\tt name} est une chaîne de caractères représentant  le nom du module tandis que
les attributs {\tt models},{ \tt ressources}, {\tt opérations} et {\tt dependencies} sont des tableaux 
représentant respectivement les  vues,  les ressources, les opérations et les dépendances. Comme 
le montre la figure \ref{tab:json}, seuls les éléments de l'attribut {\tt dependencies} sont optionnels ; 
le tableau des dépendances peut donc rester vide.

\begin{table}[ht]
 \begin{tabular}{|c|c|c|}
  \hline
     Attributs &Types & Optionnel\\
   \hline
    name &  string &  $-$\\
     \hline
    models & array & $-$\\
     \hline
    ressources & array & $-$ \\
     \hline
    operations & array &  $-$\\
     \hline
    dependencies & array & oui \\
     \hline    
\end{tabular}
\caption{Les attributs du document json permettant de stocker un module. \label{si:mod} }
\end{table}

\subsection{Les dépendances}

Le tableau {\tt dependencies} représente la liste des modules dont dépend un module.
Une dépendance est représentée par un objet doté de l'attribut {\tt name}, représentant  le nom d'un module et de l'attribut
 {\tt type} représentant le type de dépendance. L'attribut {\tt type} est optionnel et ne peut avoir  que  \og inherited \fg comme 
 valeur pour spécifier un héritage. Par défaut lorsque rien n'est spécifié, la dépendance est considérée comme une dépendance normale. 

\subsection{Les vues  \label{vues}}

\begin{figure}[tbp]

\begin{minipage}{0.5\textwidth}
\begin{center}

\begin{tabular}{|c|c|c|}
   \hline
   Attributs & Types & Optionnel \\
   \hline
   num &  integer & $-$\\
   \hline
   id  & string & $-$ \\
    \hline
   label & string & $-$ \\
   \hline
   state & string  & $-$  \\
   %\hline
   %templateUrl & object & $-$ \\
   \hline
   url & string & $-$ \\
   \hline
   icon & string & $-$ \\
   \hline
   children &  array & oui \\
   \hline
   functions & array & oui  \\
   \hline
   variables & array & oui  \\
   \hline
   actions & array & oui  \\
   \hline
 \end{tabular}
 \caption{Les attributs de l'objet  json permettant de stocker une vue. \label{si:vue} }
\end{center}
\end{minipage}

\begin{minipage}{0.5\textwidth}
\begin{center}
 \begin{tabular}{|c|c|c|}
   \hline
   Attributs & Types & Optionnel \\
   \hline
   name &  string & $-$\\
   \hline
   role  & string & oui \\
    \hline
   icon & string & oui \\
   \hline
   action & string  & oui  \\
    \hline
 \end{tabular}
 \caption{Les attributs de l'objet  json permettant de stocker une variable. \label{si:act} }
\end{center}
\end{minipage}

\end{figure}

%\begin{table}[ht]
% \begin{tabular}{|c|c|c|}
%   \hline
%   Attributs & Types & Optionnel \\
%   \hline
%   num &  integer & $-$\\
%   \hline
%   id  & string & $-$ \\
%    \hline
%   label & string & $-$ \\
%   \hline
%   state & string  & $-$  \\
%   %\hline
%   %templateUrl & object & $-$ \\
%   \hline
%   url & string & $-$ \\
%   \hline
%   icon & string & $-$ \\
%   \hline
%   children &  array & oui \\
%   \hline
%   functions & array & oui  \\
%   \hline
%   variables & array & oui  \\
%   \hline
%   actions & array & oui  \\
%   \hline
% \end{tabular}
% \caption{Les attributs de l'objet  json permettant de stocker une vue. \label{si:vue} }
%\end{table}

%\begin{table}[ht]
% \begin{tabular}{|c|c|c|}
%   \hline
%   Attributs & Types & Optionnel \\
%   \hline
%   name &  string & $-$\\
%   \hline
%   role  & string & oui \\
%    \hline
%   icon & string & oui \\
%   \hline
%   action & string  & oui  \\
%    \hline
% \end{tabular}
% \caption{Les attributs de l'objet  json permettant de stocker une variable. \label{si:act} }
%\end{table} 

\begin{table}[ht]
 \begin{tabular}{|c|c|c|}
   \hline
   Attributs & Types & Optionnel \\
   \hline
   name &  string & $-$\\
   \hline
   cache  & string & oui \\
    \hline
   service & string & oui \\
   \hline
   value & string  & oui  \\
    \hline
 \end{tabular}
 \caption{Les attributs de l'objet  json permettant de stocker une variable. \label{si:var} }
\end{table} 

\begin{table}[ht]
 \begin{tabular}{|c|c|c|}
   \hline
   Attributs & Types & Optionnel \\
   \hline
   name &  string & $-$\\
   \hline
   content  & string &  $-$ \\
    \hline
  \end{tabular}
 \caption{Les attributs de l'objet  json permettant de stocker une variable. \label{si:fun} }
\end{table} 

Le tableau {\tt models} représente l'ensemble des vues d'un module. Une vue est 
caractérisée par un objet json dont les attributs sont décrits dans le  tableau\ref{si:vue}.
Les différents attributs de la vue peuvent être regroupés en trois catégories : 

\begin{itemize}
  \item {\em configuration.}
 Les attributs {\tt state},{\tt label}, {\tt url}, {\tt icon} et {\tt actions}, représentant respectivement
 l'état, le nom, l'url , l'icône et les actions associées à la vue, sont les éléments nécessaires lors de la génération
  de la configuration.
 \item {\em model.} 
 L'attribut {\tt children}, représentant la liste des composants d'une vue, est l'élément nécessaire à la génération des pages html. 
 \item {\em controller.}
 Les attributs {\tt functions} et {\tt variables}, représentant respectivement les fonctions et les variables associées
 à une vue, sont nécessaires à la génération des contrôleurs.
\end{itemize}


L' attribut  {\tt actions} est un tableau d'objets dont les attributs sont présentés dans la table \ref{si:act}.
Les attributs {\tt name} et {\tt icon} représentent les éléments visibles de la barre  des actions (cf. \ref{reference vers la barre des actions}).
L'attribut {\tt action } représente le code à exécuter tandis que {\tt role} représente le droit qu'un utilisateur doit avoir pour faire cette action.

L' attribut  {\tt variables} est un tableau d'objets dont les attributs sont présentés dans la table \ref{si:var}.
Les attributs{\tt name} et {\tt value } sont nécessaires à la déclaration de la variable. Si la valeur de l'attribut {\tt resolve} est faux 
alors la déclaration est faite lors de la génération du contrôleur, sinon elle est faite lors de la génération de la config. Au cas où la 
déclaration est faite dans le contrôleur, si l'attribut {\tt local} est vrai, alors la variable sera générée comme une variable locale. Si
l'attribut {\tt async} est vrai, alors il faut préciser le nom du service qui permet de récupérer la valeur de la variable avec l'attribut 
{\tt service}.

L' attribut  {\tt functions} est un tableau d'objets dont les attributs sont présentés dans la table \ref{si:fun}.
pour générer une fonction, il faut deux attributs obligatoires que sont {\tt name} et {\tt content} représentant
respectivement le nom et le contenu de la fonction.

L'attribut {\tt children} est un tableau d'objet  dont les attributs sont présentés dans la table \ref{si:chi}.
l'attribut {\tt type} représente le type du composant html, et les attributs {\tt style } et {\tt class} représentent
l'habillage css du composant. L'attribut {\tt children} représente le tableau de sous-composants d'un conteneur.
Mis à part les attributs cités, chaque composant peut  insérer dans l'objet des attributs qui lui sont propres.


\subsection{Les ressources}

\begin{table}[ht]
 \begin{tabular}{|c|c|c|}
   \hline
   Attributs & Types & Optionnel \\
   \hline
   path  & string &  $-$ \\
    \hline
   parents &  string & oui\\
    \hline
   resources &  array & oui\\
    \hline
   methods &  array & oui\\
    \hline
    
  \end{tabular}
 \caption{Les attributs de l'objet  json permettant de stocker une variable. \label{si:res} }
\end{table} 

\begin{table}[ht]
 \begin{tabular}{|c|c|c|}
   \hline
   Attributs & Types & Optionnel \\
   \hline
   name  & string &  $-$ \\
    \hline
   id &  string & $-$\\
    \hline
   requests &  array & oui\\
    \hline
   responses &  array & oui\\
    \hline
   role  & string &  oui \\
    \hline
   type &  string & oui\\
    \hline
   trigger &  array & oui\\
    \hline
     
  \end{tabular}
 \caption{Les attributs de l'objet  json permettant de stocker une variable. \label{si:res} }
\end{table}

\begin{table}[ht]
 \begin{tabular}{|c|c|c|}
   \hline
   Attributs & Types & Optionnel \\
   \hline
   name  & string &  $-$ \\
   \hline
   from  & string &  $-$ \\
    \hline
  \end{tabular}
 \caption{Les attributs de l'objet  json permettant de stocker une variable. \label{si:res} }
\end{table} 
 
Le tableau {\tt resources} représente l'ensemble des ressources REST d'un module. Une ressource est 
caractérisée par un objet json dont les attributs sont décrits dans le  tableau\ref{si:res}. Les attributs 
{\tt resources} et {\tt parent } sont les éléments nécessaires pour la gestion de l'arborescence. En effet l'attribut
{\tt resources} est un tableau de mes objets que celui nous sommes en train de décrire. L'attribut {\tt path} représente l'uri d'une ressource. tandis que l'attribut {\tt methods}
représente les méthodes associées à la dite ressource.

L' attribut  {\tt methods} est un tableau d'objets dont les attributs sont présentés dans la table \ref{si:met}.
 Les attributs {\tt name}, {\tt id},  {\tt requests}, {\tt responses} sont les éléments de définition d'une ressource 
 classique. L'attribut {\tt role} permet de définir un droit d'accès sur la ressource. L'attribut {\tt type} représentant
 le type de ressource, est un élément nécessaire dans la génération du code (côté serveur). Il peut prendre les valeurs
 \og request \fg, \og command \fg, \og reply \fg, \og empty \fg, \og inheritance \fg et  \og inherited\fg. L'attribut {\tt trigger}
 représente une ressource à exécuter en tâche de fond.
 
L'attribut trigger est un objet caractérisé par l' attribut {\tt name}, représentant le 
nom de l'opération à exécuter, et l'attribut {\tt from}, représentant le nom du module de provenance.

\subsection{Les opérations}



Le tableau {\tt operations} représente l'ensemble des opérations associées aux ressources d'un module.
Une opération est caractérisée par un objet json dont les attributs sont décrits dans le  tableau\ref{si:ope}.

 \begin{table}[ht]
 \begin{tabular}{|c|c|c|}
   \hline
   Attributs & Types & Optionnel \\
   \hline
   name  & string &  $-$ \\
   \hline
   type  & string &  $-$ \\
    \hline
   reply  & string &  $-$ \\
    \hline
      sql  & object &  oui \\
    \hline
      in  & array &  $-$ \\
    \hline
  \end{tabular}
 \caption{Les attributs de l'objet  json permettant de stocker une variable. \label{si:res} }
\end{table} 


\section{Le principe de la génération}

\subsection{Les contrôleurs}

La génération des contrôleurs consiste dans un premier temps, à parcourir le tableau des variables pour en extraire les
dépendances  à injecter dans l'entête du contrôleur. Nous déclarons ensuite les variables suivi de la définition des fonctions.
Nous générons le tout dans un fichier dont le nom est la concaténation de l'attribut {\tt label} et du mot \og Ctrl \fg .


\begin{verbatim}
$scope.HTMLcomponents = HTMLcomponents;
$scope.model = globalVarFactory.getModule().models;
\end{verbatim}

La figure \ref{} est un exemple de génération des variables présentées à la figure \ref{}.
Comme on peut le constater, la génération se fait simplement en mettant les noms des variables comme attribut dans le scope 
et en leur attribuant comme valeur celle de l'attribut {\tt value} ou service.   Lorsque l'attribut {\tt resolve} a pour valeur vrai, la 
valeur de la variable  provient alors de la  dépendance injectée dans l'entête ; c'est le cas de notre variable {\tt HTMLcomponents}.

\subsection{Les services}

La génération des services consiste à créer un objet dont les attributs sont les méthodes associées aux ressources REST. 
l'idée est d'encapsuler l'appel d'une ressource REST dans un simple appel de fonction. Les services sont déclarés dans un fichier
 dont le nom est la concaténation de l'attribut {\tt label} et du mot \og Service \fg .  Ainsi, les ressources de la figure\ref{} .... à completer.
 
 %inclure une ressource et la generation du service équivalent
\subsection{Les vues}

La génération de la vue consiste à générer le code html des composants du tableau children en fonction des propriétés positionnées par
l'utilisateur. Outre les propriétés présentées à la section \ref{vues}, les composant disposent des propriétés qui leur sont propres.

%présenter  bootstrap

\paragraph{{\tt input}.} Sa génération se fait selon le modèle de la figure \ref{...}. 
\begin{verbatim}
 <DIV [class="$class"] [style="$style"]>
     [<LABEL for="$id">$label</LABEL>]
      <INPUT [readonly] [placeholder="$label"] 
	      name="$id ||$name" id="$id" type="$type" ng-model="$model"/>
 </DIV>
\end{verbatim}

\paragraph{{\tt hx}.}Sa génération se fait selon la figure \ref{}. La construction de la balise est dynamique
et dépend de la valeur de l'attribut {\tt type}. Les attributs {\tt model} et {\tt label} permettent de définir soit
un contenu dynamique soit un contenu statique. 

\begin{verbatim}
 <H$type>$label || ${model}</H$type>
\end{verbatim}

\paragraph{{\tt i}.} 
\begin{verbatim}
 <i class="$class"  [style="$style"]></i>
\end{verbatim}

\paragraph{{\tt radio}.} La génération des boutons radio se fait selon la figure \ref{}. Outre les attributs communs, 
ce composant introduit les attributs {\tt separator} et  {\tt options}, cette dernière est une chaîne de caractère constituée des
différentes options du bouton radio séparées par un séparateur spécifié par l'attribut  {\tt separator}. En effet 
pour générer ce composant, on parcourt la chaîne des options et on extrait chaque option délimiter par le séparateur, puis on génère 
un bouton pour l'option. 
\begin{verbatim}
 <DIV [class="$class"]>
	[<P>$label</P>]
	FOR item IN $options
	      <INPUT id="$id" value="$value" ng-model="$model" type="radio" name="$name" [checked]>
	      <LABEL for="$id">$item</LABEL>
	ENDFOR
  </DIV>
\end{verbatim}

%----------------------------------------------------------------------------------------------------------------------------------------------------------------------

\paragraph{{\tt textarea}.} La génération de ce composant se fait selon le code de la figure \ref{}. Il introduit
l'attribut {\tt codeEditor}, si ce dernier a pour valeur \og vrai \fg alors le composant sera générer en tant qu'éditeur
de code. Ce composant a été généré dans l'interface {\tt vue} sous les onglets \og variables \fg et  \og functions \fg .

\begin{verbatim}
 <DIV [class="$class"] [style="$style"]>
     [<LABEL for="$id">$label</LABEL>]
      <TEXTAREA  [placeholder="$label"] class="form-control"
	      name="$id ||$name" id="$id" [ui-codemirror="cmOption"] ng-model="$model"></TEXTAREA>
 </DIV>
\end{verbatim}
%----------------------------------------------------------------------------------------------------------------------------------------------------------------------

\paragraph{{\tt button}.} La génération des boutons se fait selon le code de la figure \ref{}. Le bouton introduit les attributs
{\tt div} et  {\tt dynamic}. Ces attributs sont optionnels et spécifient respectivement si l'on veut générer le bouton avec une 
balise \og div \fg au lieu de la balise \og button \fg traditionnelle, et si l'on veut que le label du bouton soit dynamique.

\begin{verbatim}
<[DIV] || [BUTTON] [class="$class"] [style="$style"] id="$id" >  $label <<[DIV] || [BUTTON]>
\end{verbatim}
%----------------------------------------------------------------------------------------------------------------------------------------------------------------------

\paragraph{{\tt select}.} La génération d'un {\tt select} se fait selon le code de la figure \ref{}. Il introduit les attributs {\tt collection}, {\tt rvalur}
et {\tt dvalue}. ces derniers sont obligatoires et spécifient  respectivement le tableau de données qui alimente le composant, la valeur retournée 
par le composant et enfin la valeur affichée. 

\begin{verbatim}
<DIV  class="form-group">
    	 [<label for="select297">$label</label>]
         <SELECT  [class="$class"] [style="$style"] name="select297" id="select297" ng-model="method.name" class="form-control" >
         		<OPTION ng-repeat='item in $collection' value="{{item.$rvalue}}"> {{item.$dvalue}} 	 </OPTION>
        </SELECT>
</DIV>
\end{verbatim} 
%----------------------------------------------------------------------------------------------------------------------------------------------------------------------

\paragraph{{\tt label}.} La génération d'un {\tt label} se fait selon le code de la figure \ref{}. Ce composant peut avoir un contenu
statique ou dynamique selon que l'utilisateur spécifie une valeur pour l'attribut {\tt label} ou spécifie la valeur de l'attribut {\tt model}.

\begin{verbatim}
<LABEL [class="$class"] [style="$style"] id="$id">[$label] || [$model] </LABEL>
\end{verbatim}
%----------------------------------------------------------------------------------------------------------------------------------------------------------------------
\paragraph{{\tt hr}•} La génération d'un {\tt label} se fait selon le code de la figure \ref{}. Ce composant n'a pas besoin de paramètres
particuliers en dehors de l'habillage css.

\begin{verbatim}
<HR [class="$class"] [style="$style"] id="$id"/>
\end{verbatim}
%----------------------------------------------------------------------------------------------------------------------------------------------------------------------

\paragraph{{\tt span}•} La génération d'un {\tt span} se fait selon le code de la figure \ref{}. Il n'a pas d'attributs particuliers et peut soit
avoir un contenu statique si l'attribut {\tt label} est renseigné ou un contenu dynamique si l'attribut{\tt model} est renseigné.

\begin{verbatim}
<SPAN [class="$class"] [style="$style"] id="$id">[$label] || [$model]</SPAN	>
\end{verbatim}
%----------------------------------------------------------------------------------------------------------------------------------------------------------------------

\paragraph{{\tt img}•} La génération du composant {\tt img} se fait selon le code de la figure \ref{}. Il introduit l'attribut {\tt src} qui permet
à l'utilisateur de spécifier la source de l'image que le composant va afficher.

\begin{verbatim}
<IMG [class="$class"] [style="$style"] id="$id" src="$src"></IMG>
\end{verbatim}
%----------------------------------------------------------------------------------------------------------------------------------------------------------------------

\paragraph{{\tt group}• }La génération du composant {\tt group} se fait selon le code de la figure \ref{}. Ce composant introduit autant d'attributs
que de paramètres nécessaires pour sa configuration. Il participe à la construction d'autres composants en fonction desquels 
ses attributs sont ou non  optionnels. En effet nous avons :

\begin{itemize}
\item {{\tt position}.} Cet attribut spécifie la position du composant sur l'écran, il possède 3 options que sont \og center \fg , \og right \fg et \og left \fg .
\item {{\tt width}.} C'est la largeur du composant, elle se définit en colonne et un {\tt group} en avoir 12 au total.
\item {{collapsible}.} Il spécifie si le composant sera pliable/ dépliable 
\item {{\tt uiview}.} spécifie si oui ou non le composant affichera des bouts de pages html associées à des états donnés.
\item {{\tt row}.} Si cet attribut a pour valeur \og vrai \fg , le contenu du composant sera afficher en ligne.
\item {{\tt src}.} Spécifie le chemin vers une page html qui s'affichera dans le composant.
\item  {{\tt expression}.} Spécifie les  conditions  dans lesquelles le composant sera affiché ou caché.
\end{itemize}

\begin{verbatim}
<DIV [class="$class"] [style="$style"]  id="$id"> </DIV>
\end{verbatim}

%----------------------------------------------------------------------------------------------------------------------------------------------------------------------
\paragraph{{\tt paragraph}• }La génération du composant {\tt group} se fait selon le code de la figure \ref{}.

\begin{verbatim}
<P  [class="$class"] [style="$style"]  id="$id"> </P>
\end{verbatim}
%----------------------------------------------------------------------------------------------------------------------------------------------------------------------
\paragraph{{\tt tab}•}La génération du composant {\tt tab} se fait selon le code de la figure \ref{}. Il est conçu à partir du composant
{\tt group}. En effet, il possède un attribut \og children \fg qui est un tableau de {\tt group}. Chaque groupe représente un onglet et ici, 
{\tt group } introduit les attributs \og index \fg et \og heading \fg qui représentent respectivement l'index de l'onglet et le nom de l'onglet.

\begin{verbatim}
 <UIB-TABSET  [class="$class"] [style="$style"]  id="$id" >
       FOR item IN children
	          <UIB-TAB index="item.num"  heading="item.label"> 
           </UIB-TAB>
       ENDFOR           
</UIB-TABSET>            
\end{verbatim}
%----------------------------------------------------------------------------------------------------------------------------------------------------------------------

\paragraph{{\tt accordion}•}La génération du composant {\tt tab} se fait selon le code de la figure \ref{}. Comme les {\tt tab}, il est aussi
conçu à partir des groupes. Ici, le seul attribut utilisé ici est \og heading \fg qui indique le nom du composant.
\begin{verbatim}
 <UIB-ACCORDION  [class="$class"] [style="$style"]  id="$id" >
       FOR item IN children
	          <UIB-TAB-GROUP   heading="item.label"> 
             </UIB-TAB-GROUP>
       ENDFOR           
</UIB-ACCORDION>            
\end{verbatim}
%----------------------------------------------------------------------------------------------------------------------------------------------------------------------
\paragraph{{\tt wizard}•}La génération du composant {\tt wizard} se fait selon le code de la figure \ref{}. Il est aussi conçu à base du composant
{\tt group}, son attribut \og children  \fg est un tableau de groupes représentant  les étapes successives du {\tt wizard}.

%----------------------------------------------------------------------------------------------------------------------------------------------------------------------

\paragraph{{\tt form }•}La génération de ce composant se fait selon le code de la figure \ref{}. Il introduit l'attribut \og formValidation \fg qui spécifie si 
oui ou non il faut inclure la validation du formulaire dans la génération. {\tt form } dispose aussi d'un attribut \og children \fg contenant les différents
sous-composants nécessaires à sa génération.

\begin{verbatim}
  <FORM no-validate [class="$class"] [style="$style"]  id="$id">  
      ::::::
  </FORM>      
\end{verbatim}

%----------------------------------------------------------------------------------------------------------------------------------------------------------------------
\paragraph{{\tt treeview }•}La génération du composant {\tt treeview} se fait selon le code de la  figure \ref{}. 










\subsection{Configuration des (routes) états}

Nous générons la configuration des états dans un fichier config. Elle se fait à base de paramètres tels que les 




\section{La présentation du générateur sous forme de module}

\subsection{Les vues}
%% faire un rappel du menu du module et présenter les actions/vues
Dans le cadre de l'implémentation de notre module, nous avons conçu via l'arbre des composants, cinq interfaces à
savoir : \og modules \fg , \og views \fg , \og resources \fg , \og operations \fg et \og overview \fg .





\subsection{Les ressources}
Nous avons défini sept ressources REST   que sont : \og modules \fg ,  \og id \fg , \og files \fg , \og fname \fg ,
 \og generate \fg et \og upload \fg . Elles représentent respectivement la liste des modules,
 les fichiers  d'un module, récupérer un fichier,  le générateur de vues et la sauvegarde.
 
  Dans le reste de cette section,  nous allons présenter pour chacune des ressources,  les méthodes et les opérations associées.
 
 \subsubsection{La liste des modules}

Elle est représentée par l'uri {\tt  /generator/modules } et dispose de deux méthodes : une pour récupérer la liste des modules et
une autre pour créer un nouveau module.

\paragraph{Liste.} Cette méthode est une requête http de type {\tt GET } à laquelle on associe l'opération {\tt modules} de type  \og requests \fg  .
Le code \ref{} représente la requête sql  exécutée par  {\tt modules}.

\begin{verbatim}
	select json_agg(foo) from 
	(select id, module from generator.modules where module->>'owner'=$1) foo
\end{verbatim}

\paragraph{Création.} Cette méthode est une requête http de type {\tt POST } à laquelle on associe l'opération {\tt newmodule} de type  \og requests \fg  .
Le code \ref{} représente la requête sql  exécutée par  {\tt newmodule}.

\begin{verbatim}
insert into generator.modules (module) values($1) returning id
\end{verbatim}

\subsubsection{ Les fichiers  d'un module}

Elle est représentée par l'uri {\tt  /generator/modules/\{id\}/files } et dispose d'une méthode  pour récupérer les tous les fichiers
d'un  module. 

La méthode est une requête http de type {\tt GET } à laquelle on associe l'opération {\tt files} de type  \og empty \fg  .
Le listing \ref{} est le code de l'opération files que nous avons écrit, elle consiste à décrire l'arborescence du répertoire d'un module
sous un format json. 

%\begin{verbatim}
%void getfiles( char *path, cJSON *tab)
%{
%  struct dirent  entry, *rs = 0;
%  DIR *d;
%  char d_path[255]; 
%  
%  if(!(d = opendir(path)))
%    return;
%   
%  while (1)
%    {
%      readdir_r(d, &entry, &rs);
%      if(!rs)
%	break;
%	      
%      if(strcmp(".", entry.d_name) && strcmp("..", entry.d_name))
%	cJSON_AddItemToArray(tab, cJSON_CreateString(entry.d_name));
%
%    }
%  closedir(d); 
%}
%\end{verbatim}

\subsubsection{Le contenu d'un fichier}
la ressource est représentée par l'uri {\tt  /generator/modules/\{id\}/files/\{type\}/\{fname\} } où id représente 
l'identifiant d'un module, type représente le type du fichier à récupérer et fname représente le nom du fichier. 
Elle  dispose de la  méthode \og file \fg  pour récupérer un  fichier donné. 

La méthode est une requête http de type {\tt GET } à laquelle on associe l'opération {\tt file} de type  \og empty \fg  .
Le code \ref{} montre notre implémentation de l'opération {\tt file}. Dans un premier temps, nous déterminons  le 
chemin relatif du fichier recherché, à partir des paramètres fournis. Dans un second temps, nous utilisons l'API
{\tt module\_localStorage\_read}, fourni par la plateforme, qui nous renvoi le contenu recherché.

%\begin{verbatim}
%void generator_getfile(module_ctx *mod)
%{
%  char name[256];
%  int restno, restlen;
%  restful_t *r = module_restful(mod);
%  char *id, *type, *fname;
%
%  restno = restful_gettemplate_param(r, "id");
%  restlen = r->params[restno].end-r->params[restno].begin;
%  id = mem_calloc(1, restlen+1);
%  snprintf(id, restlen+1, "%.*s",
%	   r->params[restno].end-r->params[restno].begin,
%	   r->path+r->params[restno].begin);
%  restno = restful_gettemplate_param(r, "type");
%  restlen = r->params[restno].end-r->params[restno].begin;
%  type = mem_calloc(1, restlen+1);
%  snprintf(type, restlen+1, "%.*s",
%	   r->params[restno].end-r->params[restno].begin,
%	   r->path+r->params[restno].begin);
%  restno = restful_gettemplate_param(r, "fname");
%  restlen = r->params[restno].end-r->params[restno].begin;
%  fname = mem_calloc(1, restlen+1);
%  snprintf(fname, restlen+1, "%.*s",
%	   r->params[restno].end-r->params[restno].begin,
%	   r->path+r->params[restno].begin);
%
%  if(!strcmp(type, "operation"))
%    snprintf(name, sizeof(name), "generator/%s/libsrc/%s", id, fname);
%  else if(!strcmp(type, "service"))
%    snprintf(name, sizeof(name), "generator/%s/www/services/%s", id, fname);
%  else if(!strcmp(type, "view"))
%    snprintf(name, sizeof(name), "generator/%s/www/views/%s", id, fname);
%  else if(!strcmp(type, "controller"))
%    snprintf(name, sizeof(name), "generator/%s/www/controllers/%s", id, fname);
%  else if(!strcmp(type, "workflow"))
%    snprintf(name, sizeof(name), "generator/%s/process/%s", id, fname);
%  else if(!strcmp(type, "sql"))
%    snprintf(name, sizeof(name), "generator/%s/sql/%s", id, fname);
%  else if(!strcmp(type, "json"))
%    snprintf(name, sizeof(name), "generator/%s/%s", id, fname);
%
%  elog_debug("%s name=%s", __func__, name);
%
%  module_localStorage_read(mod, name, getfile_done, 0);
%
%  mem_free(id);
%  mem_free(type);
%  mem_free(fname);
%}
%
%\end{verbatim}


\subsection{La base de données}
\subsection{Le générateur de vues}

\subsection{La collaboration}
%% parler de gitolite et de la manière dont on crée des branches pour
%% le module


\chapter{conclusion}


\end{document} 
