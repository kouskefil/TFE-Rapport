\documentclass[a4paper,11pt]{report}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[defaultsans]{opensans}
\usepackage{enumitem}
\usepackage{listings}
\usepackage[francais]{babel}

\DeclareRobustCommand\ebseries{\fontseries{eb}\selectfont}
\DeclareRobustCommand\sbseries{\fontseries{sb}\selectfont}
\DeclareRobustCommand\ltseries{\fontseries{l}\selectfont}
\DeclareRobustCommand\clseries{\fontseries{cl}\selectfont}

\DeclareTextFontCommand{\texteb}{\ebseries}
\DeclareTextFontCommand{\textsb}{\sbseries}
\DeclareTextFontCommand{\textlt}{\ltseries}
\DeclareTextFontCommand{\textcl}{\clseries}

\begin{document}

\chapter{Introduction}

\chapter{Le contexte du travail}
\section{Le cahier des charges ?}
\section{L'architecture de la plateforme cible}
\section{Le framework Angularjs ?}
\section{Les ressources REST}
\section{Le contrôle d'accès en utilisant des rôles (RBAC)}

\chapter{La Conception de notre générateur de module}
\section{Le concept général}
\subsection{Définition d'un module}

%Le concept de module dans une architecture client-serveur représente
%un ensemble d'éléments côté client interagissant avec d'autres
%éléments côté serveur.
Un module est une application métier\footnote{A expliquer} basée sur
l'architecture client-serveur. Nous nous référons au terme module pour
indiquer le caractère modulaire que peut prendre une application. Par
exemple,la gestion des resources humaines est un assemblage de
plusieurs sous-applications telles que la gestion des employés, la
gestion des carrières, la gestion de la paie et la gestion des
embaûches \footnote{donner la liste complète si possible}. 

L'architecture client-serveur, implique qu'un module est composé
d'une application {\em client} et d'une application {\em serveur}.
L'application client est une interface graphique\footnote{spécifier
  pourquoi c'est une interface graphique } permettant à
aux utilisateur d'interagir avec un système d'information.
%faut il parler des single page ?
L'application serveur est celle qui gère les données métiers dans un
système d'information.
La gestion des données est faite essentiellement via une base de
données et les processus métiers. 

\subsection{Le portail applicatif des modules}
%penser à definir la   %notion de SPA, s'assurer que module est
%défini%
C'est l'interface principale\footnote{parler du PAE} permettant de présenter les différentes
fonctionnalités des modules. Comme le montre la figure \ref{}, elle
est divisée en six parties à savoir :

\begin{itemize}
\item La barre d'entête (cf. le chiffre 1 sur la figure \ref{}). Cette
  partie indique le nom du module courant, la liste des tâches à
  réaliser et la liste des modules.
\item  Le bloc de menus  (cf. le chiffre 2 sur la figure \ref{}). Il
  présente les différents éléments du menu d'un module.
\item Le bloc des modules liées  (cf. le chiffre 3 sur la figure
  \ref{}). Présente la liste des modules en lien avec le module courant.
\item  L'espace de travail  (cf. le chiffre 4 sur la figure
  \ref{}).
  
\item La barre d'actions  (cf. le chiffre 5 sur la figure \ref{}). 
 
\end{itemize}

L'nterface est basée sur la notion d'applications
monopages\footnote{Aussi nommée Single Page Application (SPA) }.
De ce fait, les parties une, deux, trois et cinq sont statiques alors
que la partie 4 est dynamique. Les éléments des parties statiques
changent avec l'installation d'un nouveau module.
   
\paragraph{Actions versus menu.}
Les éléments du menu permettent de naviguer à travers les
différentes vues d'un module alors que les actions permettent de
faire des opérations sur les éléments de la vue courante. D'un point
de vue technique, la différence se trouve au niveau des composants avec
lesquels ils sont implmentés : les menus sont implémentés   sous forme
de liens et les actions boutons. 

\paragraph{Liste des modules versus modules liés}
La liste des modules de la barre d'entête représente l'ensemble des
modules installés sur le système tandisque la liste des modules liés
représente les dépendances entre différents modules. Les modules de
gestion de stocks et d'achats sont liés ou dépendent du module de la
gestion des articles. Dans ce cas de figure, le module gestion des
articles aura dans sa liste de modules liés les modules stocks et
achats. L'intérêt principal des modules liés est d'éviter à
l'utilisateur, d'aller chercher un module parmi une liste de module
qui peut vite être conséquent.

\paragraph{L'installation d'un module.}
Elle consiste, pour un module donné, à  fournir les éléments de
parties statiques. ces dernières sont ensuite positionnées dans leur
bloc respectif.

\subsection{Le principe générale}
%A completer
%parler de productivité générale
%donner tout ce qui contribut à l'amélioration de cette dernière

L'idée du générateur est d'utiliser un environnement graphique
permettant de spécifier les différents éléments nécessaires à
l'implémentation des applications client et serveur, en vue d'augmenter
la productivité générale \footnote{listing des productivités} d'un développeur. En effet, une fois les
éléments spécifiés, nous passons à la génération automatique des codes
des applications client serveur. Ceci permettra aux développeurs de se
focaliser sur la conception de leurs modules.

Nous regroupons les éléments du module en deux catégories : ceux {\em
  côté client } et ceux {\em côté serveur}.
Les éléments côté client sont ceux qui sont nécessaires pour la mise
en place de l'interface principale. Ils permettent de définir les
différentes pages ou vues html ainsi que les services qui permettent
de recupérer les données du serveur.
Les éléments côté serveur permettent de définir les bases de données,
les processus métiers et ressources permettant d'interagir avec le
client.

\paragraph{Productivité.}


\section{La présentation des éléments graphiques côté client}
%parler du MVC (séparation des vues de la donnée)%
\subsection{Overview}

\subsubsection{Présentation de la vue générale}
La vue générale se concentre sur les éléments côté client d'un
module. Elle est l'étape principale dans le processus de réalisation
d'un module. Aussi simple qu'elle parait, elle rassemble tous les
outils nécessaires pour concevoir chacun des éléments de la partie
cliente d'un module. Elle se résume à l'interface de la figure
suivante. Sous les onglets {\tt components} et {\tt treeview}, nous
disposons respectivement de la palette de composants html et de leur
organisation sur la vue en forme d'arborescence. sous les onglets {\tt
variables} et {\tt functions}, on définit les variables et les
fonctions qui sont utilisées pour écrire le contrôleur de la vue. Sous
les onglets {\tt actions} et {\tt configs} on définit respectivement
les actions du module et les paramètres de configuration de la vue. 


\subsubsection{ Les composants} % faut il lister les éléments
Ils constituent un outil graphique permettant de manipuler les
éléments qui entrent dans l'élaboration d'une interface web. Les
manipulations sont basées sur un certains nombres de propriétés que 
nous leur avons associé afin de controller leur mise en forme, leurs
attributs html ainsi que les données qu'ils manipulent.

Nous avons resencé les composants les plus couremment utilisés dans les
applications web et nous les avons regroupé en trois grandes
catégories :

\begin{itemize}
\item {\em Les composants simples};
ce sont des éléments HTML dont la définition ne nécéssite pas
l'imbrication d'un autre composant.
exemple:
%mettre un exemple délément simple
\item  {\em Les composants conteneurs} 
Ce sont des éléments qui peuvent contenir des composants de
n'importe quelle catégorie, par exemple l'élément html {\tt form}
permet de regrouper les composants simples tels que les {\tt input} et
des {\tt button} pour la réalisation d'un formulaire.
\item Les composants widgets
Ce sont des éléments non standards que nous avons entièrement écris, en
proposant leur design et leur conception.
\end{itemize}



\subsubsection{ L'arbre des composants} 
%mettre une note de bas de page pour dire les difficultés que
%rencontrent les dévelopeurs
Le concept de l'arbre des composants est d'augmenter la productivité
des dévéloppeurs en limitant le perte de temps due aux changements
récurents dans le développement des interfaces \footnote{explication détaillée}.


L'arbre des composants est un outil permettant de représenter les
composants d'une interface. Ses composants sont organisés sous forme
d'arbre afin de mieux schématiser la hiérarchie induite par les
composants conteneurs. La figure \ref{} représente l'arbre des
composants de l'interface de la figure \ref{}.

Notre concept se décline via l'interface de la figure \ref{} dans
laquelle on constate qu'un certains nombres d'actions sont associées à
chaque composant. En effet pour permettre la réutilisation de codes
nous proposons les cinq actions suivantes:

\begin{itemize}
\item Monter - descendre : elles permettent les déplacements de
  composants vers le haut ou vers le bas, dans le même conteneur. Ceci
  permet de réorganiser les composants d'un même conteneur.

\item couper : elle permet les déplacements de composants d'un
  conteneur à un autre. Ceci permet la réorganisation globale des
  composants.
\item copier : permet de cloner
 un composant, soit dans un même
  conteneur ou non. Ceci permet de générer facilement une interface avec
  des composants semblables.
\item Supprimer : elle permet d'enlever un composant de l'arborescence.
\end{itemize}

% Introduire les propriétés des composants, parler de maniere gle du
% design, de la vue et du controleur%
%montrer àpartir d'un exemple, decrire les différentes propriétés des
%composants%
%faire une reférence vers la description des autes composants se
%trouvant en annexe%
	

\subsubsection{ Les fonctions}
Le concept ici est d'améliorer la productivité du dévloppeur en :
\begin{itemize}
\item évitant les {\em erreurs d'écriture} dans les noms des
fonctions dans les vues et dans les contrôleurs.
\item proposant une {\em vue d'ensemble} du travail à réaliser (isolation ?).
\end{itemize}

Le concept se décline via l'inteface de la figure \ref{}

\paragraph{Erreur d'écriture}
Le lien \og generate functions \fg, génère les noms des fonctions, à
partir de l'arbre des composants. Les composants tels que button,
... et ... font appel à des fonctions qu'ils définissent dans leurs
propriétés. à partir des propriétés des composants cités plus haut,
nous extrayons le nom des variables à déclarer.

\paragraph{Vue d'ensemble}
Nous pouvons dinstinguer parmi les variables à définir, celles qui
sont dejà définies ou non. La définition d'une variable se fait en
l'isolant des autres variables. Ceci permet au
développeur de se focaliser sur le reste des variables et surtout de
ne pas perdre de temps à chercher une information dans les codes qui
peuvent rapideent devenir illisibles.

\subsubsection{Les variables}
Le concept ici est d'améliorer la productivité du dévloppeur en :
\begin{itemize}
\item évitant les {\em erreurs d'écriture} dans les noms des
fonctions dans les vues et dans les contrôleurs.
\item proposant une {\em vue d'ensemble} du travail à réaliser.
\item simplifiant la déclaration des variables.

\end{itemize}

Le concept se décline via l'inteface de la figure \ref{}

\paragraph{Erreur d'écriture.}
Le lien \og generate vars \fg, génère les noms des variables, à partir
de l'arbre des composants. Les composants manipulent des variables. à
partir des propriétés, nous extrayons
le nom des variables à implémenter.

\paragraph{Vue d'ensemble.}
Nous pouvons dinstinguer parmi les fonctions à implémenter, celles qui
sont dejà définies ou non. La définition d'une fonction se fait en
l'isolant\footnote{collapsible} des autres fonctions. Ceci permet au
développeur de se focaliser sur le reste des fonctions et surtout de
ne pas perdre de temps à chercher une information dans les codes qui
peuvent rapideent devenir illisibles.

\paragraph{Déclaration.}
Les variables peuvent être de type {\em resolve}, {\em async} et {\em
  cache}.  les variables de type {\em resolve} sont celles dont les
valeurs sont présentes avant le chargement de la page qui les utilise.
les variables de type {\em async} sont celles dont les valeurs
proviennent d'un serveur de manière asynchrone; dans ce cas, le
service permettant d'obtenir la donnée doit être préciser.  Les
variables de type {\em cache} sont celles dont les valeurs sont mises
ou proviennent d'un cache lorsque l'attribut cache a pour valeur {\tt
  to} ou  {\tt from}.

%service, %expliquer le
%type locale
%%

\subsubsection{ Les actions}

Ils constituent un outil graphique permettant de spécifier les actions
associées à une vue donnée.

représentent une partie des fonctionnalités
du module faisables à partir de la vue encours d'édition.  Pour
ajouter une fonction, il faut :
\begin{itemize}
\item Préciser le nom de l'action;
\item  Préciser le rôle de l'utilisateur qui peut y avoir accès;
\item Préciser l'icône  de l'action, c'est sur cette dernière qu'il faut cliquer pour exécuter l'action;
\item Préciser les dépendances;
awesome file input\item Enfin écrire le corps de la fonction de l'action
\end{itemize}

 

\subsubsection{ La configuration} 
%lobjectif depuis le debut etait deja de cacher des parties de
%l'implémentation.
Le  concept ici est d'améliorer la productivité du développeur en
simplifiant la mise en place des menus, des droits et de la navigation.
Ce concept se décline via l'interface de la figure suivante \ref{}.

\paragraph{Navigation.}
Elle consiste à construire l'état/route auquel(le) la vue est associée
tout en précisant le nom de l'état, l'url associé et le chemin static
ou dynamic du template. Ainsi, en parcourant la liste des vues, on peu
les connaître les différents états du module.
 
\paragraph{Menus.}
La case à cocher \og module menu \fg permet de spécifier si une vue
a une entrée ou non dans la liste des menus d'un module.  De ce fait,
il est possible en parcourant la liste des vues de la figure \ref{},
d'obtenir les éléments du menu. On pourra non seulement identifier
les icônes associées aux menus mais aussi changer l'ordre d'apparition
des éléments dans le menu par un simple déplacement dans la liste des vues.
 
\paragraph{Droits d'accès}

\section{La présentation des éléments graphiques côté serveur}


\subsubsection{Les resources}
Le concept ici est de faciliter l'implémentation  des APIs
REST. Ceci se décline dans l'interface de la figure \ref{}.  Elle
est divisée en trois parties à savoir : la liste des ressources, les
détails d'une ressource et les paramètres des ressources.
 \paragraph{La liste des ressources}.
Elle permet d'avoir une vue d'ensemble sur les ressources d'un module.
Son organisation en arborescence facilite la détection d'incohérences
liées aux URIs
\paragraph{Les Détails d'une ressource.}
Au delà de l'URI visible dans l'arborescence, on distingue dans  cette
partie les informations liées à une ressource. Ces dernières peuvent
être mise à jour en cliquant sur l'action {\tt update}.

\paragraph{Les paramètres d'une ressource}
Cette partie donne une vue d'ensemble des {\tt méthodes} d'une
ressources et permet aussi d'en créer de nouvelles. Une méthode est la
définition d'une opération sur la ressource.

\subsubsection{Les opérations}
Les opérations sont étroitement liées aux ressources

\subsubsection{Les données Externes}%base de données + process%


 


\chapter{L'implémentation du générateur }
\section {Les élément côté client}
\subsection{L'arbre des composants}
\subsection{Le générateur de code}
\subsection{Les vues générées}
\subsection{Les configs}
\section{Les éléments côté serveur}
\subsection{La représentation d'une ressource (basée sur le WADL) }
\subsection{La liste des ressources}
\chapter{conclusion}


\end{document} 
