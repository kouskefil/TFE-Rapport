\documentclass[a4paper,12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[defaultsans]{opensans}
\usepackage{enumitem}
\usepackage{listings}
\usepackage[frenchb]{babel}

\DeclareRobustCommand\ebseries{\fontseries{eb}\selectfont}
\DeclareRobustCommand\sbseries{\fontseries{sb}\selectfont}
\DeclareRobustCommand\ltseries{\fontseries{l}\selectfont}
\DeclareRobustCommand\clseries{\fontseries{cl}\selectfont}

\DeclareTextFontCommand{\texteb}{\ebseries}
\DeclareTextFontCommand{\textsb}{\sbseries}
\DeclareTextFontCommand{\textlt}{\ltseries}
\DeclareTextFontCommand{\textcl}{\clseries}

\begin{document}

\section{Introduction}

\section{blablabla}

\section{Conception ...}
\subsection{Le concept d'un module}

Le concept de module dans une architecture client-serveur représente un ensemble d'éléments côté client
interagissant avec d'autres éléments côté serveur.
\subsection{Les éléments côté client}
%parler du MVC (séparation des vues de la donnée)%
La partie cliente d’un module est basée sur l'architecture Model Views
Controllers et est constituée des différentes pages html du module,
des services qui permettent de récupérer les données du serveur via
les Contrôleurs.
\subsubsection{Présentation de la vue générale} %Interface de conception de la partie cliente%
\paragraph{•}
La conception de la partie cliente passe par quelques étapes que sont:
\begin{itemize}
\item La création de la vue, en cliquant sur l'icône + de la barre des actions;
\item La configuration de la vue sous l'onglet  configs;
\item La construction de la vue en cliquant sur les composants sous
  l'onglet composants et l'alignement des composants avec l'arbre des
  composants
\item La déclaration des fonctions et des variables du contrôleur de la vue
\item Et enfin la déclaration des actions liées à la vue

\end{itemize}

\subsubsection{ Les composants} % faut il lister les éléments
Ils constituent un outil graphique permettant de manipuler les
éléments qui entrent dans l'élaboration d'une interface web. Les
manipulations sont basées sur un certains nombres de propriétés que 
nous leur avons associé afin de controller leur mise en forme, leurs
attributs html ainsi que les données qu'ils manipulent.

Nous avons resencé les composants les plus couremment utilisés dans les
applications web et nous les avons regroupé en trois grandes
catégories :

\begin{itemize}
\item {\em Les composants simples};
ce sont des éléments HTML dont la définition ne nécéssite pas
l'imbrication d'un autre composant.
exemple:
%mettre un exemple délément simple
\item  {\em Les composants conteneurs} 
Ce sont des éléments qui peuvent contenir des composants de
n'importe quelle catégorie, par exemple l'élément html {\tt form}
permet de regrouper les composants simples tels que les {\tt input} et
des {\tt button} pour la réalisation d'un formulaire.
\item Les composants widgets
Ce sont des éléments non standards que nous avons entièrement écris, en
proposant leur design et leur conception.
\end{itemize}



\subsubsection{ L'arbre des composants} 
%mettre une note de bas de page pour dire les difficultés que
%rencontrent les dévelopeurs
Le concept de l'arbre des composants est d'augmenter la productivité
des dévéloppeurs en limitant le perte de temps due aux changements
récurents dans le développement des interfaces \footnote{explication détaillée}.


L'arbre des composants est un outil permettant de représenter les
composants d'une interface. Ses composants sont organisés sous forme
d'arbre afin de mieux schématiser la hiérarchie induite par les
composants conteneurs. La figure \ref{} représente l'arbre des
composants de l'interface de la figure \ref{}.

Notre concept se décline via l'inteface de la figure \ref{} dans
laquelle on constate qu'un certains nombres d'actions sont associées à
chaque composant. En effet pour permettre la réutilisation de codes
nous proposons les cinq actions suivantes:

\begin{itemize}
\item Monter - descendre : elles permettent les déplacements de
  composants vers le haut ou vers le bas, dans le même conteneur. Ceci
  permet de réorganiser les composants d'un même conteneur.

\item couper : elle permet les déplacements de composants d'un
  conteneur à un autre. Ceci permet la réorganisation globale des
  composants.
\item copier : permet de cloner
 un composant, soit dans un même
  conteneur ou non. Ceci permet de générer facilement une interface avec
  des composants semblables.
\item Supprimer : elle permet d'enlever un composant de l'arborescence.
\end{itemize}

% Introduire les propriétés des composants, parler de maniere gle du
% design, de la vue et du controleur%
%montrer àpartir d'un exemple, decrire les différentes propriétés des
%composants%
%faire une reférence vers la description des autes composants se
%trouvant en annexe%
	

\subsubsection{ Les fonctions}
Le concept ici est d'améliorer la productivité du dévloppeur en :
\begin{itemize}
\item évitant les {\em erreurs d'écriture} dans les noms des
fonctions dans les vues et dans les contrôleurs.
\item proposant une {\em vue d'ensemble} du travail à réaliser (isolation ?).
\end{itemize}

Le concept se décline via l'inteface de la figure \ref{}

\paragraph{Erreur d'écriture}
Le lien \og generate functions \fg, génère les noms des fonctions, à
partir de l'arbre des composants. Les composants tels que button,
... et ... font appel à des fonctions qu'ils définissent dans leurs
propriétés. à partir des propriétés des composants cités plus haut,
nous extrayons le nom des variables à déclarer.

\paragraph{Vue d'ensemble}
Nous pouvons dinstinguer parmi les variables à définir, celles qui
sont dejà définies ou non. La définition d'une variable se fait en
l'isolant des autres variables. Ceci permet au
développeur de se focaliser sur le reste des variables et surtout de
ne pas perdre de temps à chercher une information dans les codes qui
peuvent rapideent devenir illisibles.

\subsubsection{Les variables}
Le concept ici est d'améliorer la productivité du dévloppeur en :
\begin{itemize}
\item évitant les {\em erreurs d'écriture} dans les noms des
fonctions dans les vues et dans les contrôleurs.
\item proposant une {\em vue d'ensemble} du travail à réaliser.
\item simplifiant la déclaration des variables.

\end{itemize}

Le concept se décline via l'inteface de la figure \ref{}

\paragraph{Erreur d'écriture.}
Le lien \og generate vars \fg, génère les noms des variables, à partir
de l'arbre des composants. Les composants manipulent des variables. à
partir des propriétés, nous extrayons
le nom des variables à implémenter.

\paragraph{Vue d'ensemble.}
Nous pouvons dinstinguer parmi les fonctions à implémenter, celles qui
sont dejà définies ou non. La définition d'une fonction se fait en
l'isolant\footnote{collapsible} des autres fonctions. Ceci permet au
développeur de se focaliser sur le reste des fonctions et surtout de
ne pas perdre de temps à chercher une information dans les codes qui
peuvent rapideent devenir illisibles.

\paragraph{Déclaration.}
Les variables peuvent être de type {\em resolve}, {\em async} et {\em
  cache}.  les variables de type {\em resolve} sont celles dont les
valeurs sont présentes avant le chargement de la page qui les utilise.
les variables de type {\em async} sont celles dont les valeurs
proviennent d'un serveur de manière asynchrone; dans ce cas, le
service permettant d'obtenir la donnée doit être préciser.  Les
variables de type {\em cache} sont celles dont les valeurs sont mises
ou proviennent d'un cache lorsque l'attribut cache a pour valeur {\tt
  to} ou  {\tt from}.

%service, %expliquer le
%type locale
%%

\subsubsection{ Les actions}

Ils constituent un outil graphique permettant d'associer des actions
à une vue donnée.


Les actions représentent représentent une partie des fonctionnalités
du module faisables à partir de la vue encours d'édition.  Pour
ajouter une fonction, il faut :
\begin{itemize}
\item Préciser le nom de l'action;
\item  Préciser le rôle de l'utilisateur qui peut y avoir accès;
\item Préciser l'icône  de l'action, c'est sur cette dernière qu'il faut cliquer pour exécuter l'action;
\item Préciser les dépendances;
\item Enfin écrire le corps de la fonction de l'action
\end{itemize}

 

\subsubsection{ La configuration} 
%lobjectif depuis le debut etait deja de cacher des parties de
%l'implémentation.
Le  concept est ici est d'améliorer la productivité du développeur en
simplifiant la mise en place de la navigation, des menus et des droits.
 Ce concept se décline via l'interface de la figure suivante \ref{}.

\paragraph{Navigation}


\paragraph{Menus}
La case à cocher \og module menu \fg permet de de spécifier si une vue
a une entrée ou non dans la liste des menu d'un module.  De ce fait,
il est possible en parcourant la liste des vues de la figure \ref{},
d'obtenir les éléments du menu. On pourra non seulement identifier
les icônes associées aux menus mais aussi changer l'ordre d'apparition
des éléments dans le menu par un simple déplacement dans la liste des vues.
 
\paragraph{Droits d'accès}

\subsection{Les éléments côté serveur}
Les éléments côté serveurs sont  essentiellement  basés sur les APIs REST,
une solution de plus en plus utilisée de nos jours pour créer des web services professionnels.
REST pour REpresentationnal  State Transfer est en gros  un ensemble de règle pour créer des web services,
lesquels peuvent être utiliser pour récupérer et ou modifier et ou afficher  des informations spécifiques sur le web
sans effectuer d'opérations côté serveur. Ceci économise  énormément de temps.
\subsubsection{Les resources}
 Les ressources  sont au coeur de l'architecture des APIs REST, elles doivent donc être
 bien pensées et bien paramétrées en tenant compte des contraintes REST. Le concept ici est de
 d'assister le développeur à mettre en place ses ressources sans perdre de temps avec une interface simplifiée
 et intuitive. Ceci se décline dans l'interface de la figure ... Elle est divisée en trois parties à savoir : les liste des
 ressources, la définition de ressources et les paramètres des ressources.
 \paragraph{Ressources}
 Permet d'avoir une vue d'ensemble des ressources et leurs arborescences. Ces dernières 

\subsubsection{Les opérations}
\subsubsection{Les données Externes}%base de données + process%

\subsection{Overview}

\subsection{Conception du portail applicatif}%penser à definir la
   %notion de SPA, s'assurer que module est défini%
 Le concept ici est
d'implémenter une plateforme de de type PAE pour portail d'application d'entreprise par laquelle
les utilisateurs d'une entreprise accèdent aux différentes
applications de l'entreprise et aux données correspondantes en
fonction de leur profil. l'idéale est donc de garantir la
fluidité de la plateforme àfin d'améliorer l'expérience de navigation de
l'utilisateur. A cet effet, elle est pensée single page application,
application monopage, en gros, du lancement du portail jusq'à la fin de la
session, une seule page charge dynamiquement les données en fonction
de l'activité de l'utilisateur.Ceci lui de ne pas
s'embrouiller et de ne pas confondre l'application installée et la
plateforme d'accès.  
   
\subsubsection{Installation du module}
Le protail applicatif est en quelques sorte le squelette des
applications. Ceci se décline dans la figure ...

Après s'être connecter, l'utilisateur installe le module/l'application 
qu'il veut utiliser. L'installation consiste à remplir les différentes
parties du portail. Ainsi, on a:

\begin{itemize}
\item 1- Le nom du module;
\item 2- Lien d'accès au dashboad du module;
\item 3- Emplacement des menus du module;
\item 4- Les liens vers les modules liés au module installé;
\item 5- Barre d'opérations, où se placent les actions de la page
  courante du module;
\item 6- L'espace de travail, où s'interchangent les différentes pages
  du module
\end{itemize}

\section{Implémentation ...}
\section{conclusion}


\end{document} 
